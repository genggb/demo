##多线程相关学习：
####20210121：
    线程安全学习
    1、volatile关键字
        可见性：
            其他线程能够立即知道共享变量已经被修改了，要读取这个变量的时候，会去内存中读取，而不是从自己的工作空间中读取
        有序性：
            虚拟机会保证这个变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行
        
        volatile不能完全保证一个变量的线程安全，原因是因为Java里面的运算并非是原子操作：
        原子操作：
            即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
        
        在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：
            运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值（一写多读）
            变量不需要与其他状态变量共同参与不变约束
        
    2、synchronized关键字：1.6以后优化了synchronized
            偏向锁：
                偏向于第一个获得它的线程，假如该锁没有被其他线程所获取，那么持有偏向锁的线程将永远不需要进行同步操作
                偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销
                在Jdk1.6中，偏向锁的开关是默认开启的，适用于只有一个线程访问同步块的场景
                有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了
            轻量级锁：
                当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁
            自旋锁：
                所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。
                注意，锁在原地循环的时候，是会消耗cpu的，就相当于在执行一个啥也没有的for循环。
                所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。
                经验表明，大部分同步代码块执行的时间都是很短很短的，也正是基于这个原因，才有了轻量级锁这么个东西。
            自适应自旋锁：
                所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数。
            重量级锁：
                轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。
                被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。
                这就是说为什么重量级线程开销很大的
            
            轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。
            互斥锁(重量级锁)也称为阻塞同步、悲观锁
            
    3、总结
        volatile只是轻量级的线程可见方式，并不是轻量级的同步方式，所以并不能说volatile是轻量级的synchronized。
        synchronized关键字并非一开始就该对象加上重量级锁，也是从偏向锁，轻量级锁，再到重量级锁的过程。
        这个过程也告诉我们，假如我们一开始就知道某个同步代码块的竞争很激烈、很慢的话，那么我们一开始就应该使用重量级锁了，从而省掉一些锁转换的开销。
    